// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Tender Management API
 *
 * API для управления тендерами и предложениями.   Основные функции API включают управление тендерами (создание, изменение, получение списка) и управление предложениями (создание, изменение, получение списка).
 *
 * API version: 1.0
 */

package openapi

import (
	"context"
	"errors"
	"github.com/Masterminds/squirrel"
	"github.com/jackc/pgx/v5"
	"github.com/google/uuid"
	"log/slog"
	"net/http"
	"time"
)

// DefaultAPIService is a service that implements the logic for the DefaultAPIServicer
// This service should implement the business logic for every endpoint for the DefaultAPI API.
// Include any external packages or services that will be required by this service.
type DefaultAPIService struct {
	pg      *Postgres
	log     *slog.Logger
	builder squirrel.StatementBuilderType
}

// NewDefaultAPIService creates a default api service
func NewDefaultAPIService(pg *Postgres, log *slog.Logger) *DefaultAPIService {
	return &DefaultAPIService{
		pg:      pg,
		log:     log,
		builder: pg.Builder,
	}
}

// CheckServer - Проверка доступности сервера (good)
func (s *DefaultAPIService) CheckServer(ctx context.Context) (ImplResponse, error) {
	if err := s.pg.Pool.Ping(ctx); err != nil {
		return Response(http.StatusInternalServerError, nil), nil
	}
	return Response(http.StatusOK, "ok"), nil
}

// CreateBid - Создание нового предложения (good)
func (s *DefaultAPIService) CreateBid(ctx context.Context, createBidRequest CreateBidRequest) (ImplResponse, error) {
	const op = "CreateBid"
	log := s.log.With(slog.String("op", op))

	// Проверяем, существует ли тендер с таким ID
	tenderId, _ := s.ConvertIntoUUID(createBidRequest.TenderId)
	authorId, _ := s.ConvertIntoUUID(createBidRequest.AuthorId)

	_, err := s.getTenderById(ctx, tenderId)
	if err != nil {
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "Тендер не найден"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), nil
	}

	if createBidRequest.AuthorType == USER {
		_, err := s.getUserById(ctx, authorId)
		if err != nil {
			if errors.Is(err, ErrNoUser) {
				return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
			}
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
		}
		err1, err2 := s.userHasRights(ctx, authorId, tenderId)
		if err1 != nil {
			if errors.Is(err1, ErrUserNoRightsTender) {
				return Response(http.StatusForbidden, ErrorResponse{Reason: "Недостаточно прав для выполнения действия"}), nil
			}
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: err2.Error()}), err2
		}

	} else if createBidRequest.AuthorType == ORGANIZATION {
		_, err := s.getOrganizationById(ctx, authorId)
		if err != nil {
			if errors.Is(err, ErrNoOrganization) {
				return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Организация не существует или некорректна"}), nil
			}
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
		}
		if err := s.organizationHasRights(ctx, authorId, tenderId); err != nil {
			if errors.Is(err, ErrOrgNoRightsTender) {
				return Response(http.StatusForbidden, ErrorResponse{Reason: "Недостаточно прав для выполнения действия"}), nil
			}
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
		}

	}

	currentTime := time.Now()
	rfc3339Time := currentTime.Format(time.RFC3339)

	sql, args, err := s.builder.
		Insert("bids").
		Columns("name", "description", "status", "tender_id", "author_type", "author_id", "created_at").
		Values(createBidRequest.Name, createBidRequest.Description, CREATED, createBidRequest.TenderId, createBidRequest.AuthorType, createBidRequest.AuthorId, rfc3339Time).
		Suffix("RETURNING bid_id, created_at").
		ToSql()

	if err != nil {
		log.Error("SQL generation failed", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Internal server error"}), nil
	}

	var newBidID uuid.UUID
	var createdAt time.Time
	err = s.pg.Pool.QueryRow(ctx, sql, args...).Scan(&newBidID, &createdAt)
	if err != nil {
		log.Error("Database execution failed", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Internal server error"}), nil
	}

	bidResponse:= Bid{
		Id:          s.ConvertFromUUID(newBidID),
		Name:        createBidRequest.Name,
		Status:      CREATED_BID,
		AuthorType:  createBidRequest.AuthorType,
		AuthorId:    createBidRequest.AuthorId,
		Version:     1,
		CreatedAt:   rfc3339Time,
	}

	return Response(http.StatusOK, bidResponse), nil
}

// CreateTender - Создание нового тендера (good)
func (s *DefaultAPIService) CreateTender(ctx context.Context, createTenderRequest CreateTenderRequest) (ImplResponse, error) {
	const op = "DefaultAPIService.CreateTender"
	log := s.log.With(slog.String("op", op))

	orgId, _ := s.ConvertIntoUUID(createTenderRequest.OrganizationId)

	_, err := s.getUserByName(ctx, createTenderRequest.CreatorUsername)
	if err != nil {
		log.Error("no user by name", slog.Any("error", err))
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	if err := s.userBelongsToOrganization(ctx, createTenderRequest.CreatorUsername, orgId); err != nil {
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusForbidden, ErrorResponse{Reason: "Недостаточно прав для выполнения действия"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	currentTime := time.Now()
	rfc3339Time := currentTime.Format(time.RFC3339)

	sql, args, err := s.builder.
		Insert("tenders").
		Columns("name", "description", "status", "service_type", "organization_id", "version", "creator_username", "created_at").
		Values(createTenderRequest.Name, createTenderRequest.Description, CREATED, createTenderRequest.ServiceType, orgId, 1, createTenderRequest.CreatorUsername, rfc3339Time).
		Suffix("RETURNING id, created_at").
		ToSql()

	if err != nil {
		log.Error("Failed to build SQL", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	var id uuid.UUID
	var createdAt time.Time
	err = s.pg.Pool.QueryRow(ctx, sql, args...).Scan(&id, &createdAt)
	if err != nil {
		log.Error("Failed to execute SQL", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to create tender"}), err
	}

	tenderResponse := Tender{
		Id:             s.ConvertFromUUID(id),
		Name:           createTenderRequest.Name,
		Description:    createTenderRequest.Description,
		ServiceType:    createTenderRequest.ServiceType,
		Status:         CREATED,
		OrganizationId: createTenderRequest.OrganizationId,
		Version:        1,
		CreatedAt:      rfc3339Time,
	}

	if err = s.addVersionTableTender(ctx, createTenderRequest.CreatorUsername, &tenderResponse); err != nil {
		log.Error("Failed to add tender to the version table", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to add tender to the version table "}), err
	}
	return Response(http.StatusOK, tenderResponse), nil
}

// EditBid - Редактирование параметров предложения (good)
func (s *DefaultAPIService) EditBid(ctx context.Context, bidId string, username string, editBidRequest EditBidRequest) (ImplResponse, error) {
	const op = "EditBid"
	log := s.log.With(slog.String("op", op))

	user, err := s.getUserByName(ctx, username)
	if err != nil {
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	bidIdUUID, _ := s.ConvertIntoUUID(bidId)
	bid, err := s.getBidById(ctx, bidIdUUID)
	if err != nil {
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "Предложение не найдено"}), err
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	if err = s.addVersionTableBid(ctx, *bid); err != nil {
		log.Error("Failed to add tender to the version table", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to add tender to the version table "}), err
	}

	if bid.AuthorType == USER {
		if s.ConvertFromUUID(user.Id) != bid.AuthorId {
			log.Error("user has no permission to edit this bid",
				slog.Any("user", s.ConvertFromUUID(user.Id)),
				slog.Any("bid", bid.AuthorId))

			return Response(http.StatusForbidden, ErrorResponse{Reason: "Недостаточно прав для выполнения действия"}), err
		}
	} else {
		orgIdUUID, _ := s.ConvertIntoUUID(bid.AuthorId)
		if err := s.userBelongsToOrganization(ctx, user.Username, orgIdUUID); err != nil {
			if errors.Is(err, ErrNotFound) {
				return Response(http.StatusForbidden, ErrorResponse{Reason: "Недостаточно прав для выполнения действия"}), err
			}
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
		}
	}

	sqlBuilder := s.builder.Update("bids").Set("version", bid.Version+1)

	if editBidRequest.Name != "" {
		sqlBuilder = sqlBuilder.Set("name", editBidRequest.Name)
	}
	if editBidRequest.Description != "" {
		sqlBuilder = sqlBuilder.Set("description", editBidRequest.Description)
	}

	sql, args, err := sqlBuilder.Where(squirrel.Eq{"bid_id": bidIdUUID}).ToSql()
	if err != nil {
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to edit bid."}), nil
	}

	_, err = s.pg.Pool.Exec(ctx, sql, args...)
	if err != nil {
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to edit bid."}), nil
	}

	updatedBid, err := s.getBidById(ctx, bidIdUUID)
	if err != nil {
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to get updated bid"}), nil
	}

	return Response(http.StatusOK, updatedBid), nil
}

// EditTender - Редактирование тендера (good)
func (s *DefaultAPIService) EditTender(ctx context.Context, tenderId string, username string, editTenderRequest EditTenderRequest) (ImplResponse, error) {
	const op = "EditTender"
	log := s.log.With(slog.String("op", op))


	tenderIdUUID, err := s.ConvertIntoUUID(tenderId)
	if err != nil {
		log.Error("Invalid tenderId format", slog.Any("error", err))
		return Response(http.StatusBadRequest, ErrorResponse{Reason: "Invalid ID format. Must be UUID formatted"}), err
	}

	user, err := s.getUserByName(ctx, username)
	if err != nil {
		log.Error("no user by name", slog.Any("error", err))
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	err1, err2 := s.userHasRights(ctx, user.Id, tenderIdUUID)
	if err1 != nil {
		if errors.Is(err1, ErrUserNoRightsTender) {
			log.Error("user does not have rights for the tender", slog.Any("error", err2))
			return Response(http.StatusForbidden, ErrorResponse{"Недостаточно прав для выполнения действия"}), err2
		}
		log.Error("error to find a user sql error", slog.Any("error", err2))
		return Response(http.StatusInternalServerError, ErrorResponse{"couldn't process an sql query"}), err2
	}

	oldTender, err := s.getTenderById(ctx, tenderIdUUID)
	if err != nil {
		log.Error("Failed to get oldTender", slog.Any("error", err))
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "Tender not found"}), err
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to get oldTender."}), err
	}

	if err = s.addVersionTableTender(ctx, username, oldTender); err != nil {
		log.Error("Failed to add tender to the version table", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to add tender to the version table "}), err
	}

	queryBuilder := s.builder.
		Update("tenders").
		Where(squirrel.Eq{"id": tenderIdUUID}).
		Set("version", oldTender.Version+1).
		Set("updated_at", time.Now().Format(time.RFC3339))

	if editTenderRequest.Name != "" {
		queryBuilder = queryBuilder.Set("name", editTenderRequest.Name)
	}
	if editTenderRequest.Description != "" {
		queryBuilder = queryBuilder.Set("description", editTenderRequest.Description)
	}
	if editTenderRequest.ServiceType != "" {
		queryBuilder = queryBuilder.Set("service_type", editTenderRequest.ServiceType)
	}

	query, args, err := queryBuilder.Suffix("RETURNING id, name, description, service_type, status, organization_id, creator_username, created_at").ToSql()
	if err != nil {
		log.Error("error to build a query", slog.Any("error", err))
		return Response(http.StatusNotFound, ErrorResponse{err.Error()}), ErrSQLQuery
	}

	_, err = s.pg.Pool.Exec(ctx, query, args...)
	if err != nil {
		log.Error("error to build a query pool", slog.Any("error", err))
		return Response(http.StatusNotFound, ErrorResponse{Reason: "Tender not found"}), ErrSQLQuery
	}

	newTender, err := s.getTenderById(ctx, tenderIdUUID)
	if err != nil {
		log.Error("Failed to get New Tender", slog.Any("error", err))
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "Tender not found"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to get oldTender."}), nil
	}

	return Response(http.StatusOK, newTender), nil
}

// GetBidReviews - Просмотр отзывов на прошлые предложения (not)
func (s *DefaultAPIService) GetBidReviews(ctx context.Context, tenderId string, authorUsername string, requesterUsername string, limit int32, offset int32) (ImplResponse, error) {
	const op = "GetBidReviews"
	log := s.log.With(slog.String("operation", op))

	// Convert tenderId to UUID
	tenderIdUUID, err := s.ConvertIntoUUID(tenderId)
	if err != nil {
		log.Error("Invalid tenderId format", slog.Any("error", err))
		return Response(http.StatusBadRequest, ErrorResponse{Reason: "Invalid ID format. Must be UUID formatted"}), err
	}

	_, err = s.getUserByName(ctx, requesterUsername)
	if err != nil {
		log.Error("No user found with provided requesterUsername", slog.Any("error", err))
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Requester user does not exist or is incorrect"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	author, err := s.getUserByName(ctx, authorUsername)
	if err != nil {
		log.Error("No user found with provided authorUsername", slog.Any("error", err))
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Author user does not exist or is incorrect"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	sqlBuilder := s.builder.
		Select("f.feedback_id", "f.feedback", "f.created_at").
		From("bid_feedback  f").
		Join("bids ON bids.bid_id = f.bid_id").
		Where(squirrel.Eq{"bids.tender_id": tenderIdUUID, "bids.author_id": author.Id}).
		OrderBy("f.created_at DESC").
		Limit(uint64(limit)).
		Offset(uint64(offset))

	q, args, err := sqlBuilder.ToSql()
	if err != nil {
		log.Error("error to build query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	// Execute query
	rows, err := s.pg.Pool.Query(ctx, q, args...)
	if err != nil {
		log.Error("error to execute query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}
	defer rows.Close()

	var reviews []BidReview
	var createdTime time.Time

	for rows.Next() {
		var review BidReview
		err := rows.Scan(&review.Id, &review.Description, &createdTime)
		if err != nil {
			log.Error("error parsing review data", slog.Any("error", err))
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
		}
		review.CreatedAt = createdTime.Format(time.RFC3339)
		reviews = append(reviews, review)
	}

	if len(reviews) == 0 {
		log.Error("no reviews found", slog.Any("tender_id", tenderId))
		return Response(http.StatusNotFound, ErrorResponse{Reason: "No reviews found for the provided tender and author"}), nil
	}

	log.Info("successfully got bid reviews")
	return Response(http.StatusOK, reviews), nil
}

// GetBidStatus - Получение текущего статуса предложения (good)
func (s *DefaultAPIService) GetBidStatus(ctx context.Context, bidId string, username string) (ImplResponse, error) {
	const op = "GetBidStatus"
	log := s.log.With(slog.String("op", op))

	bidIdUUID, err := s.ConvertIntoUUID(bidId)
	if err != nil {
		log.Error("tenderid is not uuid", slog.Any("error", err))
		return Response(http.StatusBadRequest , ErrorResponse{Reason: "Ivalid ID parameter. Must be UUID formatted"}), err
	}

	user, err := s.getUserByName(ctx, username)
	if err != nil {
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	bid, err := s.getBidById(ctx, bidIdUUID)
	if err != nil {
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "Предложение не найдено"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	if bid.AuthorType == USER {
		if s.ConvertFromUUID(user.Id) != bid.AuthorId {
			log.Error("user has no permission to edit this bid",
				slog.Any("user", s.ConvertFromUUID(user.Id)),
				slog.Any("bid", bid.AuthorId))

			return Response(http.StatusForbidden, ErrorResponse{Reason: "Недостаточно прав для выполнения действия"}), nil
		}
	} else {
		orgIdUUID, _ := s.ConvertIntoUUID(bid.AuthorId)
		if err := s.userBelongsToOrganization(ctx, user.Username, orgIdUUID); err != nil {
			if errors.Is(err, ErrNotFound) {
				return Response(http.StatusForbidden, ErrorResponse{Reason: "Недостаточно прав для выполнения действия"}), nil
			}
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
		}
	}

	builder := s.builder.Select("status").
		From("bids").
		Where(squirrel.Eq{"bid_id": bidIdUUID})

	q, args, err := builder.ToSql()
	if err != nil {
		log.Error("error to build a query", slog.Any("error", err))
		return Response(http.StatusNotFound, ErrorResponse{err.Error()}), ErrSQLQuery
	}

	var status BidStatus
	err = s.pg.Pool.QueryRow(ctx, q, args...).Scan(&status)
	if err != nil {
		log.Error("error to build a query pool", slog.Any("error", err))
		return Response(http.StatusNotFound, ErrorResponse{Reason: "Tender not found"}), ErrSQLQuery
	}

	return Response(http.StatusOK, status), nil
}

// GetBidsForTender - Получение списка предложений для тендера (good)
func (s *DefaultAPIService) GetBidsForTender(ctx context.Context, tenderId string, username string, limit int32, offset int32) (ImplResponse, error) {
	const op = "DefaultAPIService.GetBidsForTender"
	log := s.log.With(slog.String("op", op))

	user, err := s.getUserByName(ctx, username)
	if err != nil {
		log.Error("couldn't find user", slog.Any("error", err))
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	tenderIdUUID, err := s.ConvertIntoUUID(tenderId)
	if err != nil {
		log.Error("tenderid is not uuid", slog.Any("error", err))
		return Response(http.StatusBadRequest , ErrorResponse{Reason: "Ivalid ID parameter. Must be UUID formatted"}), err
	}

	_, err = s.getTenderById(ctx, tenderIdUUID)
	if err != nil {
		log.Error("Failed to get New Tender", slog.Any("error", err))
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "Tender not found"}), err
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to get oldTender."}), err
	}


	err1, err2 := s.userHasRights(ctx, user.Id, tenderIdUUID)
	if err1 != nil {
		if errors.Is(err1, ErrUserNoRightsTender) {
			log.Error("user does not have rights for the tender", slog.Any("error", err2))
			return Response(http.StatusForbidden, ErrorResponse{"Недостаточно прав для выполнения действия"}), err2
		}
		log.Error("error to find a user sql error", slog.Any("error", err2))
		return Response(http.StatusInternalServerError, ErrorResponse{"couldn't process an sql query"}), err2
	}

	query := `
    SELECT bid_id, name, status, author_type, author_id, version, created_at 
    FROM bids 
    WHERE tender_id = $1 
    LIMIT $2 
    OFFSET $3`

	// Выполняем запрос
	rows, err := s.pg.Pool.Query(ctx, query, tenderIdUUID, limit, offset)
	if err != nil {
		log.Error("failed to fetch bids", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}
	defer rows.Close()

	var bids []Bid
	for rows.Next() {
		var bid Bid
		var createdTime time.Time
		err := rows.Scan(&bid.Id, &bid.Name, &bid.Status, &bid.AuthorType, &bid.AuthorId, &bid.Version ,&createdTime)
		if err != nil {
			log.Error("failed to scan bid", slog.Any("error", err))
			return Response(http.StatusInternalServerError, ErrorResponse{"failed to scan bid"}), err
		}
		bid.CreatedAt = createdTime.Format(time.RFC3339)
		bids = append(bids, bid)
	}

	if rows.Err() != nil {
		log.Error("error iterating over rows", slog.Any("error", rows.Err()))
		return Response(http.StatusInternalServerError, ErrorResponse{"Ошибка при обработке данных"}), rows.Err()
	}

	return Response(http.StatusOK, bids), nil
}

// GetTenderStatus - Получение текущего статуса тендера (good)
func (s *DefaultAPIService) GetTenderStatus(ctx context.Context, tenderId string, username string) (ImplResponse, error) {
	const op = "GetTenderStatus"
	log := s.log.With(slog.String("op", op))

	tenderIdUUID, err := s.ConvertIntoUUID(tenderId)
	if err != nil {
		log.Error("tenderid is not uuid", slog.Any("error", err))
		return Response(http.StatusBadRequest, ErrorResponse{Reason:"Ivalid ID parameter. Must be UUID formatted" }), err
	}

	_, err = s.getTenderById(ctx, tenderIdUUID)
	if err != nil {
		log.Error("Failed to get New Tender", slog.Any("error", err))
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "Tender not found"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to get oldTender."}), nil
	}

	builder := s.builder.Select("t.status").
		From("tenders t").
		Where(squirrel.Eq{"t.id": tenderIdUUID})

	if username != "" {
		_, err := s.getUserByName(ctx, username)
		if err != nil {
			log.Error("couldn't find user by username", slog.Any("error", err))
			if errors.Is(err, ErrNoUser) {
				return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
			}
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
		}
		builder.Join("organization_responsible or ON t.organization_id = or.organization_id").
			Join("employee e ON e.id = or.user_id").
			Where(squirrel.Eq{"e.username": username})
	}

	q, args, err := builder.ToSql()
	if err != nil {
		log.Error("failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	var status TenderStatus

	err = s.pg.Pool.QueryRow(ctx, q, args...).Scan(&status)
	if err != nil {
		log.Error("error to build a query pool", slog.Any("error", err))
		if errors.Is(pgx.ErrNoRows, err) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: err.Error()}), err
		}
		return  Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	return Response(http.StatusOK, status), nil
}

// GetTenders - Получение списка тендеров (протестил)
// Request: GET
func (s *DefaultAPIService) GetTenders(ctx context.Context, limit int32, offset int32, serviceType []TenderServiceType) (ImplResponse, error) {
	s.log.Info("Request received in GetTenders", slog.Int("limit", int(limit)), slog.Int("offset", int(offset)), slog.Any("serviceType", serviceType))

    for i := range serviceType {
        if !serviceType[i].IsValid() {
            return Response(http.StatusBadRequest, ErrorResponse{Reason: "service type not valid."}), nil
        }
    }

    queryBuilder := s.builder.
        Select("id, name, description, service_type, status, organization_id, version, created_at").
        From("tenders").
        Limit(uint64(limit)).
        Offset(uint64(offset))

    if len(serviceType) > 0 {
        queryBuilder = queryBuilder.Where(squirrel.Eq{"service_type": serviceType})
    }

	if limit > 0 {
        queryBuilder = queryBuilder.Limit(uint64(limit))
    }

    if offset > 0 {
        queryBuilder = queryBuilder.Offset(uint64(offset))
    }

    sql, args, err := queryBuilder.ToSql()
    if err != nil {
        s.log.Error("Failed to build SQL", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
    }

    s.log.Info("SQL query built", slog.String("sql", sql), slog.Any("args", args))

    rows, err := s.pg.Pool.Query(ctx, sql, args...)
    if err != nil {
        s.log.Error("Failed to execute query", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Database query failed"}), err
    }
    defer rows.Close()

	var timeInTender time.Time

    var tenders []Tender
    for rows.Next() {
        var tender Tender
        err := rows.Scan(&tender.Id, &tender.Name, &tender.Description, &tender.ServiceType, &tender.Status, &tender.OrganizationId, &tender.Version, &timeInTender)
        if err != nil {
            s.log.Error("Failed to scan row", slog.Any("error", err))
            return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to parse database result"}), err
        }
		tender.CreatedAt = timeInTender.Format(time.RFC3339)
        tenders = append(tenders, tender)
    }

    if err = rows.Err(); err != nil {
        s.log.Error("Error during rows iteration", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Error while fetching tenders"}), err
    }

    s.log.Info("Successfully fetched tenders", slog.Any("tenders", tenders))

	if tenders == nil {
		return ImplResponse {Code: http.StatusOK, Body: "Rows are empty."}, nil
	}

    return ImplResponse{
        Code: http.StatusOK,
        Body: tenders,
    }, nil
}

// GetUserBids - Получение списка ваших предложений (протестил)
// Request: GET
func (s *DefaultAPIService) GetUserBids(ctx context.Context, limit int32, offset int32, username string) (ImplResponse, error) {
	if username == "" {
		return Response(http.StatusBadRequest, ErrorResponse{Reason: "username dose nor exist."}), nil
	}
	
	var userId uuid.UUID
	sql, args, err := s.builder.
		Select("id").
		From("employee").
		Where(squirrel.Eq{"username": username}).
		ToSql()

	if err != nil {
		s.log.Error("Failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	err = s.pg.Pool.QueryRow(ctx, sql, args...).Scan(&userId)
	if err != nil {
		s.log.Error("Failed to execute SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Database query error"}), err
	}

	sql, args, err = s.builder.
		Select("bid_id, name, status, author_type, author_id, version, created_at").
		From("bids").
		Where(squirrel.Eq{"author_id": userId}).
		Limit(uint64(limit)).
		Offset(uint64(offset)).
		ToSql()

	if err != nil {
		s.log.Error("Failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	rows, err := s.pg.Pool.Query(ctx, sql, args...)
	if err != nil {
		s.log.Error("Failed to execute SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Database query error"}), err
	}
	defer rows.Close()

	var timeInBid time.Time

	var bids []Bid
	for rows.Next() {
		var bid Bid
		if err := rows.Scan(&bid.Id, &bid.Name, &bid.Status, &bid.AuthorType, &bid.AuthorId, &bid.Version, &timeInBid); err != nil {
			s.log.Error("Failed to scan row", slog.Any("error", err))
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Data scan error"}), err
		}
		bid.CreatedAt = timeInBid.Format(time.RFC3339)
		bids = append(bids, bid)
	}

	if err := rows.Err(); err != nil {
		s.log.Error("Error occurred during rows iteration", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Rows iteration error"}), err
	}

	if bids == nil {
		return ImplResponse {Code: http.StatusOK, Body: "Rows are empty."}, nil
	}

	return Response(http.StatusOK, bids), nil
}

// GetUserTenders - Получить тендеры пользователя (протестил)
// Request: Get
func (s *DefaultAPIService) GetUserTenders(ctx context.Context, limit int32, offset int32, username string) (ImplResponse, error) {
	if username == "" {
		return Response(http.StatusBadRequest, ErrorResponse{Reason: "username dose nor exist."}), nil
	}

	sql, args, err := s.builder.
		Select("id, name, description, status, service_type, version, created_at").
		From("tenders").
		Where(squirrel.Eq{"creator_username": username}).
		Limit(uint64(limit)).
		Offset(uint64(offset)).
		ToSql()

	if err != nil {
		s.log.Error("Failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	rows, err := s.pg.Pool.Query(ctx, sql, args...)
	if err != nil {
		s.log.Error("Failed to execute SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Database query error"}), err
	}
	defer rows.Close()

	var tenders []Tender
	var tendersTime time.Time
	for rows.Next() {
		var tender Tender
		if err := rows.Scan(&tender.Id, &tender.Name, &tender.Description, &tender.Status, &tender.ServiceType, &tender.Version, &tendersTime); err != nil {
			s.log.Error("Failed to scan row", slog.Any("error", err))
			return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Data scan error"}), err
		}
		tender.CreatedAt = tendersTime.Format(time.RFC3339)
		tenders = append(tenders, tender)
	}

	if err := rows.Err(); err != nil {
		s.log.Error("Error occurred during rows iteration", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Rows iteration error"}), err
	}

	if tenders == nil {
		return ImplResponse {Code: http.StatusOK, Body: "Rows are empty."}, nil
	}

	return Response(http.StatusOK, tenders), nil
}

// RollbackBid - Откат версии предложения (not)
func (s *DefaultAPIService) RollbackBid(ctx context.Context, bidId string, version int32, username string) (ImplResponse, error) {
    query, args, err := s.pg.Builder.
        Select("bid_id, name, description, status, tender_id, author_type, author_id, version, created_at").
        From("bids").
        Where(squirrel.Eq{"bid_id": bidId}).
        ToSql()

    if err != nil {
        s.log.Error("Failed to build SQL for bid lookup", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Internal server error"}), err
    }

	var currentTimeBid time.Time
    var currentBid Bid
    err = s.pg.Pool.QueryRow(ctx, query, args...).Scan(
        &currentBid.Id, &currentBid.Name, &currentBid.Description, &currentBid.Status, 
        &currentBid.TenderId, &currentBid.AuthorType, &currentBid.AuthorId, &currentBid.Version, 
        &currentTimeBid)
    
    if err != nil {
        s.log.Error("Bid not found", slog.Any("error", err))
        return Response(http.StatusNotFound, ErrorResponse{Reason: "Bid not found"}), err
    }

    query, args, err = s.pg.Builder.
        Select("bid_id, name, description, status, tender_id, author_type, author_id, version, created_at").
        From("bids_versions").
        Where(squirrel.Eq{"bid_id": bidId, "version": version}).
        ToSql()

    if err != nil {
        s.log.Error("Failed to build SQL for version lookup", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Internal server error"}), err
    }

	var rollbackTimeBid time.Time
    var rollbackVersion Bid
    err = s.pg.Pool.QueryRow(ctx, query, args...).Scan(
        &rollbackVersion.Id, &rollbackVersion.Name, &rollbackVersion.Description, &rollbackVersion.Status, 
        &rollbackVersion.TenderId, &rollbackVersion.AuthorType, &rollbackVersion.AuthorId, &rollbackVersion.Version, 
        &rollbackTimeBid)
    
    if err != nil {
        s.log.Error("Version not found", slog.Any("error", err))
        return Response(http.StatusNotFound, ErrorResponse{Reason: "Version not found"}), err
    }

    query, args, err = s.pg.Builder.
        Update("bids").
        Set("name", rollbackVersion.Name).
        Set("description", rollbackVersion.Description).
        Set("status", rollbackVersion.Status).
        Set("tender_id", rollbackVersion.TenderId).
        Set("author_type", rollbackVersion.AuthorType).
        Set("author_id", rollbackVersion.AuthorId).
        Set("version", rollbackVersion.Version).
        Where(squirrel.Eq{"bid_id": bidId}).
        ToSql()

    if err != nil {
        s.log.Error("Failed to build SQL for bid update", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Internal server error"}), err
    }

    _, err = s.pg.Pool.Exec(ctx, query, args...)
    if err != nil {
        s.log.Error("Failed to update bid", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to update bid"}), err
    }

    return Response(http.StatusOK, "Откатил..."), nil
}

// RollbackTender - Откат версии тендера (good)
func (s *DefaultAPIService) RollbackTender(ctx context.Context, tenderId string, version int32, username string) (ImplResponse, error) {
	const op = "RollbackTender"
	log := s.log.With(slog.String("op", op))

	if version < 1 {
		log.Error("Version cannot be less than 1")
		return Response(http.StatusBadRequest, ErrorResponse{Reason: "Version cannot be less than 1"}), errors.New("Version cannot be less than 1")
	}
	tenderIdUUID, err := s.ConvertIntoUUID(tenderId)
	if err != nil {
		log.Error("tenderid is not uuid", slog.Any("error", err))
		return Response(http.StatusBadRequest , ErrorResponse{Reason: "Ivalid ID parameter. Must be UUID formatted"}), err
	}

	oldTender, err := s.getTenderById(ctx, tenderIdUUID)
	if err != nil {
		log.Error("Failed to get New Tender", slog.Any("error", err))
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "Tender not found"}), err
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to get oldTender."}), err
	}

	user, err := s.getUserByName(ctx, username)
	if err != nil {
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), err
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	err1, err2 := s.userHasRights(ctx, user.Id, tenderIdUUID)
	if err1 != nil {
		if errors.Is(err1, ErrUserNoRightsTender) {
			log.Error("user does not have rights for the tender", slog.Any("error", err1))
			return Response(http.StatusForbidden, ErrorResponse{"Недостаточно прав для выполнения действия"}), err2
		}
		log.Error("error to find a user sql error", slog.Any("error", err2))
		return Response(http.StatusInternalServerError, ErrorResponse{"couldn't process an sql query"}), err2
	}

	if err := s.addVersionTableTender(ctx, user.Username, oldTender); err != nil {
		log.Error("Failed to add tender to the version table", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to add tender to the version table "}), err
	}

	sql := `DELETE FROM tenders WHERE id = $1`

	_, err = s.pg.Pool.Exec(ctx, sql, tenderId)

	if err != nil {
		log.Error("failed to execute delete query", slog.Any("err", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	sql, args, err := s.builder.
		Select("tender_id", "name", "description", "service_type", "status", "organization_id", "version", "updated_at").
		From("tender_versions").
		Where(squirrel.Eq{"tender_id": tenderIdUUID, "version": version}).
		ToSql()



	if err != nil {
		s.log.Error("Failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	var createdTime time.Time
	var oldIdUUID uuid.UUID
	var orgIdUUID uuid.UUID

	err = s.pg.Pool.QueryRow(ctx, sql, args...).Scan(
		&oldIdUUID,
		&oldTender.Name,
		&oldTender.Description,
		&oldTender.ServiceType,
		&oldTender.Status,
		&orgIdUUID,
		&oldTender.Version,
		&createdTime,
	)

	if err != nil {
		log.Error("error to build a query pool", slog.Any("error", err))
		if errors.Is(pgx.ErrNoRows, err) {

			return Response(http.StatusOK, "empty return body, there is no data"), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	oldTender.CreatedAt = createdTime.Format(time.RFC3339)
	oldTender.Id = oldIdUUID.String()
	oldTender.OrganizationId = orgIdUUID.String()


	sql, args, err = s.builder.
		Insert("tenders").
		Columns("id", "name", "description", "status", "service_type", "organization_id", "creator_username", "version", "created_at").
		Values(oldIdUUID, oldTender.Name, oldTender.Description, oldTender.Status, oldTender.ServiceType, orgIdUUID, username, oldTender.Version , oldTender.CreatedAt).
		Suffix("RETURNING id, created_at").
		ToSql()

	if err != nil {
		log.Error("Failed to build SQL", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	_, err = s.pg.Pool.Exec(ctx, sql, args...)
	if err != nil {
		log.Error("Failed to execute SQL", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to create tender"}), err
	}

	return Response(http.StatusOK, oldTender), nil
}

// SubmitBidDecision - Отправка решения по предложению (good)
func (s *DefaultAPIService) SubmitBidDecision(ctx context.Context, bidId string, decision BidDecision, username string) (ImplResponse, error) {
	const op = "SubmitBidDecision"
	log := s.log.With(slog.String("op", op))

	bidIdUUID, err := s.ConvertIntoUUID(bidId)
	if err != nil {
		log.Error("tenderid is not uuid", slog.Any("error", err))
		return Response(http.StatusBadRequest, ErrorResponse{Reason:"Ivalid ID parameter. Must be UUID formatted" }), err
	}

	user, err := s.getUserByName(ctx, username)
	if err != nil {
		log.Error("no user by name", slog.Any("error", err))
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	sqlCheck, argsCheck, err := s.builder.Select("1").
		From("bids").
		Join("tenders ON tenders.id = bids.tender_id").
		Join("organization_responsible ON organization_responsible.organization_id = tenders.organization_id").
		Where(squirrel.Eq{
			"bids.bid_id":           bidIdUUID,
			"organization_responsible.user_id": user.Id,
		}).
		Limit(1).
		ToSql()

	if err != nil {
		log.Error("failed to build SQL query for rights check", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Не удалось построить SQL запрос"}), err
	}

	var hasRights int
	err = s.pg.Pool.QueryRow(ctx, sqlCheck, argsCheck...).Scan(&hasRights)
	if err != nil || hasRights == 0 {
		log.Error("user has no permission to edit this bid", slog.Any("user", user.Id), slog.Any("bid", bidIdUUID))
		return Response(http.StatusForbidden, ErrorResponse{Reason: "Недостаточно прав для изменения статуса бида"}), nil
	}

	createdAt := time.Now().Format(time.RFC3339)
	sql, args, err := s.builder.
		Insert("bid_feedback").
		Columns("bid_id", "feedback", "username", "created_at").
		Values(bidIdUUID, decision, username, createdAt).
		ToSql()

	if err != nil {
		log.Error("Failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	_, err = s.pg.Pool.Exec(ctx, sql, args...)
	if err != nil {
		log.Error("Failed to execute SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}


	oldBid, err := s.getBidById (ctx, bidIdUUID)
	if err != nil {
		log.Error("Failed to get bid", slog.Any("error", err))
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "bid not found"}), err
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to get old bid."}), err
	}

	log.Info("Bid decision successfully submitted")
	return Response(http.StatusOK, oldBid), nil
}

// SubmitBidFeedback - Отправка отзыва по предложению (good)
func (s *DefaultAPIService) SubmitBidFeedback(ctx context.Context, bidId string, bidFeedback string, username string) (ImplResponse, error) {
	const op = "SubmitBidFeedback"
	log := s.log.With(slog.String("op", op))

	bidIdUUID, err := s.ConvertIntoUUID(bidId)
	if err != nil {
		log.Error("tenderid is not uuid", slog.Any("error", err))
		return Response(http.StatusBadRequest, ErrorResponse{Reason:"Ivalid ID parameter. Must be UUID formatted" }), err
	}

	_, err = s.getUserByName(ctx, username)
	if err != nil {
		log.Error("no user by name", slog.Any("error", err))
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	oldBid, err := s.getBidById (ctx, bidIdUUID)

	if err != nil {
		log.Error("Failed to get bid", slog.Any("error", err))
		if errors.Is(err, ErrNotFound) {
			return Response(http.StatusNotFound, ErrorResponse{Reason: "bid not found"}), err
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Failed to get old bid."}), err
	}

	createdAt := time.Now().Format(time.RFC3339)

	query, args, err := s.builder.Insert("bid_feedback").
		Columns("bid_id", "feedback", "username", "created_at").
		Values(oldBid.Id, bidFeedback, username, createdAt).ToSql()

	if err != nil {
		log.Error("Failed to build SQL", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	_, err = s.pg.Pool.Exec(ctx, query, args...)
	if err != nil {
		log.Error("error to build a query pool", slog.Any("error", err))
		return Response(http.StatusNotFound, ErrorResponse{Reason: "Tender not found"}), ErrSQLQuery
	}
	respondBid := Bid{
		Id: oldBid.Id,
		Name: oldBid.Name,
		Status: oldBid.Status,
		AuthorType: oldBid.AuthorType,
		AuthorId: oldBid.AuthorId,
		Version: oldBid.Version,
		CreatedAt: oldBid.CreatedAt,
	}
	return Response(http.StatusOK, respondBid), nil
}

// UpdateBidStatus - Изменение статуса предложения (протестил)
func (s *DefaultAPIService) UpdateBidStatus(ctx context.Context, bidId string, status BidStatus, username string) (ImplResponse, error) {
    if !status.IsValid() {
        return Response(http.StatusBadRequest, ErrorResponse{Reason: "Invalid bid status"}), nil
    }

	bidIdUUID, err := s.ConvertIntoUUID(bidId)
	if err != nil {
		s.log.Error("tenderid is not uuid", slog.Any("error", err))
		return Response(http.StatusBadRequest , ErrorResponse{Reason: "Ivalid ID parameter. Must be UUID formatted"}), err
	}

    var userId uuid.UUID
    sql, args, err := s.builder.
        Select("id").
        From("employee").
        Where(squirrel.Eq{"username": username}).
        ToSql()

    if err != nil {
        s.log.Error("Failed to build SQL query", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
    }

    err = s.pg.Pool.QueryRow(ctx, sql, args...).Scan(&userId)
    if err != nil {
        s.log.Error("Failed to execute SQL query to get user id", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Database query error"}), err
    }

    var existingAuthorId uuid.UUID
    sql, args, err = s.builder.
        Select("author_id").
        From("bids").
        Where(squirrel.Eq{"bid_id": bidIdUUID}).
        ToSql()

    if err != nil {
        s.log.Error("Failed to build SQL query to check bid author", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
    }

    err = s.pg.Pool.QueryRow(ctx, sql, args...).Scan(&existingAuthorId)
    if err != nil {
        s.log.Error("Failed to execute SQL query to check bid author", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Database query error"}), err
    }

    if existingAuthorId != userId {
        return Response(http.StatusForbidden, ErrorResponse{Reason: "You are not the author of this bid"}), nil
    }

	if status.IsValid() == false {
		return Response(http.StatusBadRequest, ErrorResponse{"Status not correct."}), nil
	}

    sql, args, err = s.builder.
        Update("bids").
        Set("status", status).
        Where(squirrel.Eq{"bid_id": bidIdUUID}).
        ToSql()

    if err != nil {
        s.log.Error("Failed to build SQL query to update bid status", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
    }

    cmdTag, err := s.pg.Pool.Exec(ctx, sql, args...)
    if err != nil {
        s.log.Error("Failed to execute SQL query to update bid status", slog.Any("error", err))
        return Response(http.StatusInternalServerError, ErrorResponse{Reason: "Database query error"}), err
    }

    if cmdTag.RowsAffected() == 0 {
        return Response(http.StatusNotFound, ErrorResponse{Reason: "Bid not found or not updated"}), nil
    }

	newBid, err := s.getBidById(ctx, bidIdUUID)
	if err != nil {
		s.log.Error("Failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error (bidID)"}), err
	}

	s.log.Info(newBid.Name)

    return Response(http.StatusOK, newBid), nil
}

// UpdateTenderStatus - Изменение статуса тендера (протестил)
func (s *DefaultAPIService) UpdateTenderStatus(ctx context.Context, tenderId string, status TenderStatus, username string) (ImplResponse, error) {
	const op = "UpdateTenderStatus"
	log := s.log.With(slog.String("operation", op))

	tenderIdUUID, err := s.ConvertIntoUUID(tenderId)
	if err != nil {
		log.Error("tenderid is not uuid", slog.Any("error", err))
		return Response(http.StatusBadRequest , ErrorResponse{Reason: "Ivalid ID parameter. Must be UUID formatted"}), err
	}

	user, err := s.getUserByName(ctx, username)
	if err != nil {
		log.Error("no user by name", slog.Any("error", err))
		if errors.Is(err, ErrNoUser) {
			return Response(http.StatusUnauthorized, ErrorResponse{Reason: "Пользователь не существует или некорректен"}), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: err.Error()}), err
	}

	err1, err2 := s.userHasRights(ctx, user.Id, tenderIdUUID)
	if err1 != nil {
		if errors.Is(err1, ErrUserNoRightsTender) {
			log.Error("user does not have rights for the tender", slog.Any("error", err2))
			return Response(http.StatusForbidden, ErrorResponse{"Недостаточно прав для выполнения действия"}), err2
		}
		log.Error("error to find a user sql error", slog.Any("error", err2))
		return Response(http.StatusInternalServerError, ErrorResponse{"couldn't process an sql query"}), err2
	}

	if status.IsValid() == false {
		return Response(http.StatusBadRequest, ErrorResponse{"Status not correct."}), nil
	}

	query, args, err := s.builder.Update("tenders").
		Set("status", status).
		Where(squirrel.Eq{"id": tenderIdUUID}).
		ToSql()

	if err != nil {
		s.log.Error("Failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	_, err = s.pg.Pool.Exec(ctx, query, args...)
	if err != nil {
		log.Error("error to build a query pool", slog.Any("error", err))
		if errors.Is(pgx.ErrNoRows, err) {
			return Response(http.StatusNotFound, "empty return body, there is no data"), nil
		}
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	newTender, err := s.getTenderById(ctx, tenderIdUUID)
	if err != nil {
		s.log.Error("Failed to build SQL query", slog.Any("error", err))
		return Response(http.StatusInternalServerError, ErrorResponse{Reason: "SQL query error"}), err
	}

	s.log.Info(newTender.Name)

	return Response(http.StatusOK, newTender), nil
}
