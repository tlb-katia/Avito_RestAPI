// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Tender Management API
 *
 * API для управления тендерами и предложениями.   Основные функции API включают управление тендерами (создание, изменение, получение списка) и управление предложениями (создание, изменение, получение списка).
 *
 * API version: 1.0
 */

 package openapi

 import (
	 "encoding/json"
	 "net/http"
	 "strings"
 
	 "github.com/gorilla/mux"
 )
 
 // DefaultAPIController binds http requests to an api service and writes the service results to the http response
 type DefaultAPIController struct {
	 service      DefaultAPIServicer
	 errorHandler ErrorHandler
 }
 
 // DefaultAPIOption for how the controller is set up.
 type DefaultAPIOption func(*DefaultAPIController)
 
 // WithDefaultAPIErrorHandler inject ErrorHandler into controller
 func WithDefaultAPIErrorHandler(h ErrorHandler) DefaultAPIOption {
	 return func(c *DefaultAPIController) {
		 c.errorHandler = h
	 }
 }
 
 // NewDefaultAPIController creates a default api controller
 func NewDefaultAPIController(s DefaultAPIServicer, opts ...DefaultAPIOption) *DefaultAPIController {
	 controller := &DefaultAPIController{
		 service:      s,
		 errorHandler: DefaultErrorHandler,
	 }
 
	 for _, opt := range opts {
		 opt(controller)
	 }
 
	 return controller
 }
 
 // Routes returns all the api routes for the DefaultAPIController
 func (c *DefaultAPIController) Routes() Routes {
	 return Routes{
		 "CheckServer": Route{
			 strings.ToUpper("Get"),
			 "/api/ping",
			 c.CheckServer,
		 },
		 "CreateBid": Route{
			 strings.ToUpper("Post"),
			 "/api/bids/new",
			 c.CreateBid,
		 },
		 "CreateTender": Route{
			 strings.ToUpper("Post"),
			 "/api/tenders/new",
			 c.CreateTender,
		 },
		 "EditBid": Route{
			 strings.ToUpper("Patch"),
			 "/api/bids/{bidId}/edit",
			 c.EditBid,
		 },
		 "EditTender": Route{
			 strings.ToUpper("Patch"),
			 "/api/tenders/{tenderId}/edit",
			 c.EditTender,
		 },
		 "GetBidReviews": Route{
			 strings.ToUpper("Get"),
			 "/api/bids/{tenderId}/reviews",
			 c.GetBidReviews,
		 },
		 "GetBidStatus": Route{
			 strings.ToUpper("Get"),
			 "/api/bids/{bidId}/status",
			 c.GetBidStatus,
		 },
		 "GetBidsForTender": Route{
			 strings.ToUpper("Get"),
			 "/api/bids/{tenderId}/list",
			 c.GetBidsForTender,
		 },
		 "GetTenderStatus": Route{
			 strings.ToUpper("Get"),
			 "/api/tenders/{tenderId}/status",
			 c.GetTenderStatus,
		 },
		 "GetTenders": Route{
			 strings.ToUpper("Get"),
			 "/api/tenders",
			 c.GetTenders,
		 },
		 "GetUserBids": Route{
			 strings.ToUpper("Get"),
			 "/api/bids/my",
			 c.GetUserBids,
		 },
		 "GetUserTenders": Route{
			 strings.ToUpper("Get"),
			 "/api/tenders/my",
			 c.GetUserTenders,
		 },
		 "RollbackBid": Route{
			 strings.ToUpper("Put"),
			 "/api/bids/{bidId}/rollback/{version}",
			 c.RollbackBid,
		 },
		 "RollbackTender": Route{
			 strings.ToUpper("Put"),
			 "/api/tenders/{tenderId}/rollback/{version}",
			 c.RollbackTender,
		 },
		 "SubmitBidDecision": Route{
			 strings.ToUpper("Put"),
			 "/api/bids/{bidId}/submit_decision",
			 c.SubmitBidDecision,
		 },
		 "SubmitBidFeedback": Route{
			 strings.ToUpper("Put"),
			 "/api/bids/{bidId}/feedback",
			 c.SubmitBidFeedback,
		 },
		 "UpdateBidStatus": Route{
			 strings.ToUpper("Put"),
			 "/api/bids/{bidId}/status",
			 c.UpdateBidStatus,
		 },
		 "UpdateTenderStatus": Route{
			 strings.ToUpper("Put"),
			 "/api/tenders/{tenderId}/status",
			 c.UpdateTenderStatus,
		 },
	 }
 }
 
 // CheckServer - Проверка доступности сервера
 func (c *DefaultAPIController) CheckServer(w http.ResponseWriter, r *http.Request) {
	 result, err := c.service.CheckServer(r.Context())
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // CreateBid - Создание нового предложения
 func (c *DefaultAPIController) CreateBid(w http.ResponseWriter, r *http.Request) {
	 createBidRequestParam := CreateBidRequest{}
	 d := json.NewDecoder(r.Body)
	 d.DisallowUnknownFields()
	 if err := d.Decode(&createBidRequestParam); err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 if err := AssertCreateBidRequestRequired(createBidRequestParam); err != nil {
		 c.errorHandler(w, r, err, nil)
		 return
	 }
	 if err := AssertCreateBidRequestConstraints(createBidRequestParam); err != nil {
		 c.errorHandler(w, r, err, nil)
		 return
	 }
	 result, err := c.service.CreateBid(r.Context(), createBidRequestParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // CreateTender - Создание нового тендера
 func (c *DefaultAPIController) CreateTender(w http.ResponseWriter, r *http.Request) {
	 createTenderRequestParam := CreateTenderRequest{}
	 d := json.NewDecoder(r.Body)
	 d.DisallowUnknownFields()
	 if err := d.Decode(&createTenderRequestParam); err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 if err := AssertCreateTenderRequestRequired(createTenderRequestParam); err != nil {
		 c.errorHandler(w, r, err, nil)
		 return
	 }
	 if err := AssertCreateTenderRequestConstraints(createTenderRequestParam); err != nil {
		 c.errorHandler(w, r, err, nil)
		 return
	 }
	 result, err := c.service.CreateTender(r.Context(), createTenderRequestParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // EditBid - Редактирование параметров предложения
 func (c *DefaultAPIController) EditBid(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 bidIdParam := params["bidId"]
	 if bidIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"bidId"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 editBidRequestParam := EditBidRequest{}
	 d := json.NewDecoder(r.Body)
	 d.DisallowUnknownFields()
	 if err := d.Decode(&editBidRequestParam); err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 if err := AssertEditBidRequestRequired(editBidRequestParam); err != nil {
		 c.errorHandler(w, r, err, nil)
		 return
	 }
	 if err := AssertEditBidRequestConstraints(editBidRequestParam); err != nil {
		 c.errorHandler(w, r, err, nil)
		 return
	 }
	 result, err := c.service.EditBid(r.Context(), bidIdParam, usernameParam, editBidRequestParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // EditTender - Редактирование тендера
 func (c *DefaultAPIController) EditTender(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 tenderIdParam := params["tenderId"]
	 if tenderIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"tenderId"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 editTenderRequestParam := EditTenderRequest{}
	 d := json.NewDecoder(r.Body)
	 d.DisallowUnknownFields()
	 if err := d.Decode(&editTenderRequestParam); err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 if err := AssertEditTenderRequestRequired(editTenderRequestParam); err != nil {
		 c.errorHandler(w, r, err, nil)
		 return
	 }
	 if err := AssertEditTenderRequestConstraints(editTenderRequestParam); err != nil {
		 c.errorHandler(w, r, err, nil)
		 return
	 }
	 result, err := c.service.EditTender(r.Context(), tenderIdParam, usernameParam, editTenderRequestParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // GetBidReviews - Просмотр отзывов на прошлые предложения
 func (c *DefaultAPIController) GetBidReviews(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 tenderIdParam := params["tenderId"]
	 if tenderIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"tenderId"}, nil)
		 return
	 }
	 var authorUsernameParam string
	 if query.Has("authorUsername") {
		 param := query.Get("authorUsername")
 
		 authorUsernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "authorUsername"}, nil)
		 return
	 }
	 var requesterUsernameParam string
	 if query.Has("requesterUsername") {
		 param := query.Get("requesterUsername")
 
		 requesterUsernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "requesterUsername"}, nil)
		 return
	 }
	 var limitParam int32
	 if query.Has("limit") {
		 param, err := parseNumericParameter[int32](
			 query.Get("limit"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
			 WithMaximum[int32](50),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			 return
		 }
 
		 limitParam = param
	 } else {
		 var param int32 = 5
		 limitParam = param
	 }
	 var offsetParam int32
	 if query.Has("offset") {
		 param, err := parseNumericParameter[int32](
			 query.Get("offset"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			 return
		 }
 
		 offsetParam = param
	 } else {
		 var param int32 = 0
		 offsetParam = param
	 }
	 result, err := c.service.GetBidReviews(r.Context(), tenderIdParam, authorUsernameParam, requesterUsernameParam, limitParam, offsetParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // GetBidStatus - Получение текущего статуса предложения
 func (c *DefaultAPIController) GetBidStatus(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 bidIdParam := params["bidId"]
	 if bidIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"bidId"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 result, err := c.service.GetBidStatus(r.Context(), bidIdParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // GetBidsForTender - Получение списка предложений для тендера
 func (c *DefaultAPIController) GetBidsForTender(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 tenderIdParam := params["tenderId"]
	 if tenderIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"tenderId"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 var limitParam int32
	 if query.Has("limit") {
		 param, err := parseNumericParameter[int32](
			 query.Get("limit"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
			 WithMaximum[int32](50),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			 return
		 }
 
		 limitParam = param
	 } else {
		 var param int32 = 5
		 limitParam = param
	 }
	 var offsetParam int32
	 if query.Has("offset") {
		 param, err := parseNumericParameter[int32](
			 query.Get("offset"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			 return
		 }
 
		 offsetParam = param
	 } else {
		 var param int32 = 0
		 offsetParam = param
	 }
	 result, err := c.service.GetBidsForTender(r.Context(), tenderIdParam, usernameParam, limitParam, offsetParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // GetTenderStatus - Получение текущего статуса тендера
 func (c *DefaultAPIController) GetTenderStatus(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 tenderIdParam := params["tenderId"]
	 if tenderIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"tenderId"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
	 }
	 result, err := c.service.GetTenderStatus(r.Context(), tenderIdParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // GetTenders - Получение списка тендеров
 func (c *DefaultAPIController) GetTenders(w http.ResponseWriter, r *http.Request) {
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 var limitParam int32
	 if query.Has("limit") {
		 param, err := parseNumericParameter[int32](
			 query.Get("limit"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
			 WithMaximum[int32](50),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			 return
		 }
 
		 limitParam = param
	 } else {
		 var param int32 = 5
		 limitParam = param
	 }
	 var offsetParam int32
	 if query.Has("offset") {
		 param, err := parseNumericParameter[int32](
			 query.Get("offset"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			 return
		 }
 
		 offsetParam = param
	 } else {
		 var param int32 = 0
		 offsetParam = param
	 }
	 var serviceTypeParam []TenderServiceType
	 if query.Has("service_type") {
		 paramSplits := strings.Split(query.Get("service_type"), ",")
		 serviceTypeParam = make([]TenderServiceType, 0, len(paramSplits))
		 for _, param := range paramSplits {
			 paramEnum, err := NewTenderServiceTypeFromValue(param)
			 if err != nil {
				 c.errorHandler(w, r, &ParsingError{Param: "service_type", Err: err}, nil)
				 return
			 }
			 serviceTypeParam = append(serviceTypeParam, paramEnum)
		 }
	 }
	 result, err := c.service.GetTenders(r.Context(), limitParam, offsetParam, serviceTypeParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // GetUserBids - Получение списка ваших предложений
 func (c *DefaultAPIController) GetUserBids(w http.ResponseWriter, r *http.Request) {
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 var limitParam int32
	 if query.Has("limit") {
		 param, err := parseNumericParameter[int32](
			 query.Get("limit"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
			 WithMaximum[int32](50),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			 return
		 }
 
		 limitParam = param
	 } else {
		 var param int32 = 5
		 limitParam = param
	 }
	 var offsetParam int32
	 if query.Has("offset") {
		 param, err := parseNumericParameter[int32](
			 query.Get("offset"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			 return
		 }
 
		 offsetParam = param
	 } else {
		 var param int32 = 0
		 offsetParam = param
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
	 }
	 result, err := c.service.GetUserBids(r.Context(), limitParam, offsetParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // GetUserTenders - Получить тендеры пользователя
 func (c *DefaultAPIController) GetUserTenders(w http.ResponseWriter, r *http.Request) {
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 var limitParam int32
	 if query.Has("limit") {
		 param, err := parseNumericParameter[int32](
			 query.Get("limit"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
			 WithMaximum[int32](50),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			 return
		 }
 
		 limitParam = param
	 } else {
		 var param int32 = 5
		 limitParam = param
	 }
	 var offsetParam int32
	 if query.Has("offset") {
		 param, err := parseNumericParameter[int32](
			 query.Get("offset"),
			 WithParse[int32](parseInt32),
			 WithMinimum[int32](0),
		 )
		 if err != nil {
			 c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			 return
		 }
 
		 offsetParam = param
	 } else {
		 var param int32 = 0
		 offsetParam = param
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
	 }
	 result, err := c.service.GetUserTenders(r.Context(), limitParam, offsetParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // RollbackBid - Откат версии предложения
 func (c *DefaultAPIController) RollbackBid(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 bidIdParam := params["bidId"]
	 if bidIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"bidId"}, nil)
		 return
	 }
	 versionParam, err := parseNumericParameter[int32](
		 params["version"],
		 WithRequire[int32](parseInt32),
		 WithMinimum[int32](1),
	 )
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 result, err := c.service.RollbackBid(r.Context(), bidIdParam, versionParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // RollbackTender - Откат версии тендера
 func (c *DefaultAPIController) RollbackTender(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 tenderIdParam := params["tenderId"]
	 if tenderIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"tenderId"}, nil)
		 return
	 }
	 versionParam, err := parseNumericParameter[int32](
		 params["version"],
		 WithRequire[int32](parseInt32),
		 WithMinimum[int32](1),
	 )
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Param: "version", Err: err}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 result, err := c.service.RollbackTender(r.Context(), tenderIdParam, versionParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // SubmitBidDecision - Отправка решения по предложению
 func (c *DefaultAPIController) SubmitBidDecision(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 bidIdParam := params["bidId"]
	 if bidIdParam == "" {
		 c.errorHandler(w, r, &ValidationError {"bidId"}, nil)
		 return
	 }
	 var decisionParam BidDecision
	 if query.Has("decision") {
		 param := BidDecision(query.Get("decision"))
		 if !param.IsValid() {
			 c.errorHandler(w, r, &RequiredError{Field: "decision"}, nil)
			 return
		 }
		 decisionParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "decision"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 result, err := c.service.SubmitBidDecision(r.Context(), bidIdParam, decisionParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // SubmitBidFeedback - Отправка отзыва по предложению
 func (c *DefaultAPIController) SubmitBidFeedback(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 bidIdParam := params["bidId"]
	 if bidIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"bidId"}, nil)
		 return
	 }
	 var bidFeedbackParam string
	 if query.Has("bidFeedback") {
		 param := query.Get("bidFeedback")
 
		 bidFeedbackParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "bidFeedback"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 result, err := c.service.SubmitBidFeedback(r.Context(), bidIdParam, bidFeedbackParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // UpdateBidStatus - Изменение статуса предложения
 func (c *DefaultAPIController) UpdateBidStatus(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 bidIdParam := params["bidId"]
	 if bidIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"bidId"}, nil)
		 return
	 }
	 var statusParam BidStatus
	 if query.Has("status") {
		 param := BidStatus(query.Get("status"))
 
		 statusParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "status"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 result, err := c.service.UpdateBidStatus(r.Context(), bidIdParam, statusParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 
 // UpdateTenderStatus - Изменение статуса тендера
 func (c *DefaultAPIController) UpdateTenderStatus(w http.ResponseWriter, r *http.Request) {
	 params := mux.Vars(r)
	 query, err := parseQuery(r.URL.RawQuery)
	 if err != nil {
		 c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		 return
	 }
	 tenderIdParam := params["tenderId"]
	 if tenderIdParam == "" {
		 c.errorHandler(w, r, &RequiredError{"tenderId"}, nil)
		 return
	 }
	 var statusParam TenderStatus
	 if query.Has("status") {
		 param := TenderStatus(query.Get("status"))
 
		 statusParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "status"}, nil)
		 return
	 }
	 var usernameParam string
	 if query.Has("username") {
		 param := query.Get("username")
 
		 usernameParam = param
	 } else {
		 c.errorHandler(w, r, &RequiredError{Field: "username"}, nil)
		 return
	 }
	 result, err := c.service.UpdateTenderStatus(r.Context(), tenderIdParam, statusParam, usernameParam)
	 // If an error occurred, encode the error with the status code
	 if err != nil {
		 c.errorHandler(w, r, err, &result)
		 return
	 }
	 // If no error, encode the body and the result code
	 _ = EncodeJSONResponse(result.Body, &result.Code, w)
 }
 